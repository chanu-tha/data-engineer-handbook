Let's break down the changed_records and unnested_changed_records Common Table Expressions (CTEs) in your PostgreSQL query. These CTEs are crucial for handling Type 2 Slowly Changing Dimensions (SCD), where you track changes to attributes by adding new rows and maintaining a history of changes.Understanding changed_records CTEThe changed_records CTE is designed to identify players whose scoring_class or is_active status has changed from the last_season_scd (2021) to this_season_data (2022). For each such player, it generates two records:The old (expired) record: This captures the state of the player from the previous season (last_season_scd) and sets its end_season to the current_season (2022), indicating when this record became inactive.The new (current) record: This captures the player's updated state for the current_season (2022) and sets both its start_season and end_season to 2022, signifying the beginning of the new active period for this state.Let's look at the key syntax:UNNEST(ARRAY[ ... ]) as records:ARRAY[...]: This creates an array of records. Each element within the array is a ROW construct.ROW(...): This constructs a single row (or a record).ROW(ls.scoring_class, ls.is_active, ls.start_season, ls.end_season)::scd_type creates a record using the values from last_season_scd and explicitly casts it to your custom scd_type. This represents the old version of the player's data. Note that ls.end_season (which was 2021) is kept for the old record.ROW(ts.scoring_class, ts.is_active, ts.current_season, ts.current_season)::scd_type creates a record using the new values from this_season_data and casts it to scd_type. This represents the new, active version of the player's data for the current season (2022).UNNEST(...): This is a powerful PostgreSQL function that expands an array into a set of rows. If you have an array with two elements, UNNEST will return two rows, one for each element. In this case, it takes the array of two scd_type records (the old and the new) and "unnests" them into separate rows.LEFT JOIN last_season_scd ls ON ls.player_name = ts.player_name: It uses a LEFT JOIN to ensure that even players present in this_season_data but not in last_season_scd (which would be handled by new_records) are still considered in case their attributes have changed (though the WHERE clause filters for changes).WHERE (ts.scoring_class <> ls.scoring_class OR ts.is_active <> ls.is_active): This is the core condition to identify "changed" records. It selects only those players where either their scoring_class or is_active status has differed between the previous season's SCD entry and the current season's raw data.In essence, changed_records generates two rows for every player whose attributes (scoring_class or is_active) have changed: one row for the historical, now-ended record, and one for the new, current record.Understanding unnested_changed_records CTEThe unnested_changed_records CTE serves a straightforward purpose: to extract the individual fields from the records column (which is of type scd_type) generated by the changed_records CTE, turning them into separate columns.(records::scd_type).scoring_class: This is how you access individual fields within a composite type (like your scd_type).records refers to the column that holds the scd_type composite value from the changed_records CTE.::scd_type is an explicit cast, though often PostgreSQL can infer this. It ensures the system knows you're treating records as the scd_type..scoring_class accesses the scoring_class field within that scd_type record.This CTE effectively "flattens" the complex records column into standard, individual columns (scoring_class, is_active, start_season, end_season), making them ready to be combined with other CTEs using UNION ALL.Why this approach for SCD Type 2?This method ensures:Historical Accuracy: The old record is preserved but marked with an end_season, showing when its validity ceased.Current State: A new record is created with the updated attributes and a start_season/end_season covering the current period.By using UNNEST and custom types, you can generate multiple output rows from a single input row in a structured way, which is very efficient for managing SCDs directly within a SQL query.
